# ELF 64-bit Program Header Entry
# Specification: Tool Interface Standard (TIS) Executable and Linking Format (ELF) Specification Version 1.2
# Platform: Linux, BSD, Solaris - 64-bit architectures
# Purpose: Parsing a single program header table entry (Elf64_Phdr)
#
# Program headers describe segments for the program loader (ld.so).
# They define how the file should be loaded into memory at runtime.
# Each entry is 56 bytes for ELF64.
#
# Usage: Point to e_phoff + (entry_index * e_phentsize) from the ELF header
# Reference: https://refspecs.linuxfoundation.org/elf/elf.pdf
# See also: readelf -l, /usr/include/elf.h

name: ELF 64-bit Program Header Entry
description: |
  Program header table entry describing a segment to be loaded into memory.
  Defines type (LOAD, DYNAMIC, INTERP, etc.), permissions, alignment, and
  file/memory mapping for the segment. Critical for executable loading.
endian: little  # Should match ELF header's e_ident[EI_DATA]

fields:
  - name: p_type
    offset: 0x00
    size: 4
    type: u32
    description: "Segment type - defines how to interpret the segment"
    enum:
      0: "PT_NULL (Unused entry)"
      1: "PT_LOAD (Loadable segment)"
      2: "PT_DYNAMIC (Dynamic linking information)"
      3: "PT_INTERP (Path to interpreter / ld.so)"
      4: "PT_NOTE (.note section - auxiliary info)"
      5: "PT_SHLIB (Reserved, unspecified semantics)"
      6: "PT_PHDR (Program header table itself)"
      7: "PT_TLS (Thread-Local Storage template)"
      1685382480: "PT_GNU_EH_FRAME (0x6474e550 - GCC exception handling)"
      1685382481: "PT_GNU_STACK (0x6474e551 - Stack executability)"
      1685382482: "PT_GNU_RELRO (0x6474e552 - Read-only after relocation)"
      1685382483: "PT_GNU_PROPERTY (0x6474e553 - GNU property note)"
      1879048192: "PT_LOOS (0x70000000 - OS-specific start)"
      2147483647: "PT_HIOS (0x7FFFFFFF - OS-specific end)"
      2147483648: "PT_LOPROC (0x80000000 - Processor-specific start)"
      4294967295: "PT_HIPROC (0xFFFFFFFF - Processor-specific end)"

  - name: p_flags
    offset: 0x04
    size: 4
    type: u32
    description: "Segment permissions: PF_X=1, PF_W=2, PF_R=4 (bitwise OR)"
    display: hex
    # Common values: 1=X, 2=W, 3=WX, 4=R, 5=RX, 6=RW, 7=RWX
    # Bit 0: PF_X (Execute)
    # Bit 1: PF_W (Write)
    # Bit 2: PF_R (Read)
    
  - name: p_offset
    offset: 0x08
    size: 8
    type: u64
    description: "Offset of segment in file (bytes from start of file)"
    display: hex
    
  - name: p_vaddr
    offset: 0x10
    size: 8
    type: u64
    description: "Virtual address where segment should be loaded in memory"
    display: hex
    
  - name: p_paddr
    offset: 0x18
    size: 8
    type: u64
    description: "Physical address (rarely used; usually same as vaddr)"
    display: hex
    
  - name: p_filesz
    offset: 0x20
    size: 8
    type: u64
    description: "Size of segment in file (bytes) - may be 0 for BSS"
    display: hex
    
  - name: p_memsz
    offset: 0x28
    size: 8
    type: u64
    description: "Size of segment in memory (bytes) - may exceed filesz for BSS"
    display: hex
    
  - name: p_align
    offset: 0x30
    size: 8
    type: u64
    description: "Alignment constraint: 0/1=no alignment, power of 2 otherwise"
    display: hex
    # Common values: 0x1000 (4KB), 0x10000 (64KB), 0x200000 (2MB)
    # If p_align > 1: p_vaddr â‰¡ p_offset (mod p_align)
