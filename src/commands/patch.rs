//! Binary patch command for applying patches to binary files.
//!
//! This module provides functionality to apply binary patches generated by
//! `binfiddle diff --format patch` or created manually.
//!
//! # Patch Format
//!
//! The patch format is a simple line-based format:
//! ```text
//! # binfiddle patch file
//! # source: original.bin
//! # target: modified.bin
//! # format: OFFSET:OLD_HEX:NEW_HEX
//! # differences: N
//! #
//! 0x00000000:de:ff
//! 0x00000002:22:33
//! ```
//!
//! Each data line has the format: `OFFSET:OLD_HEX:NEW_HEX`
//! - OFFSET: Hexadecimal offset (with or without 0x prefix)
//! - OLD_HEX: Expected bytes at offset (empty for additions)
//! - NEW_HEX: New bytes to write (empty for deletions)
//!
//! # Examples
//!
//! ```bash
//! # Apply a patch file
//! binfiddle patch target.bin changes.patch -o patched.bin
//!
//! # Dry run to preview changes
//! binfiddle patch target.bin changes.patch --dry-run
//!
//! # In-place with backup
//! binfiddle patch target.bin changes.patch --in-file --backup .bak
//!
//! # Revert a patch
//! binfiddle patch patched.bin changes.patch --revert -o original.bin
//! ```

use crate::error::{BinfiddleError, Result};

/// Configuration for patch operations.
#[derive(Debug, Clone, Default)]
pub struct PatchConfig {
    /// Create a backup file with this suffix before modifying
    pub backup_suffix: Option<String>,
    /// Only show what would be done, don't actually modify
    pub dry_run: bool,
    /// Apply the patch in reverse (swap old and new)
    pub revert: bool,
}

/// Represents a single patch entry.
///
/// Each entry describes a modification at a specific offset:
/// - For changes: both old_bytes and new_bytes are present
/// - For additions: old_bytes is empty, new_bytes contains data to add
/// - For deletions: old_bytes contains data to remove, new_bytes is empty
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PatchEntry {
    /// Byte offset where the patch applies
    pub offset: usize,
    /// Expected bytes at this offset (empty for pure additions)
    pub old_bytes: Vec<u8>,
    /// New bytes to write (empty for pure deletions)
    pub new_bytes: Vec<u8>,
}

impl PatchEntry {
    /// Creates a new patch entry.
    pub fn new(offset: usize, old_bytes: Vec<u8>, new_bytes: Vec<u8>) -> Self {
        Self {
            offset,
            old_bytes,
            new_bytes,
        }
    }

    /// Returns true if this is a pure addition (no old bytes).
    pub fn is_addition(&self) -> bool {
        self.old_bytes.is_empty() && !self.new_bytes.is_empty()
    }

    /// Returns true if this is a pure deletion (no new bytes).
    pub fn is_deletion(&self) -> bool {
        !self.old_bytes.is_empty() && self.new_bytes.is_empty()
    }

    /// Returns true if this is a byte change.
    pub fn is_change(&self) -> bool {
        !self.old_bytes.is_empty() && !self.new_bytes.is_empty()
    }

    /// Returns the entry with old and new bytes swapped (for reverting).
    pub fn reversed(&self) -> Self {
        Self {
            offset: self.offset,
            old_bytes: self.new_bytes.clone(),
            new_bytes: self.old_bytes.clone(),
        }
    }
}

/// Result of applying a single patch entry.
#[derive(Debug, Clone)]
pub struct PatchResult {
    /// The patch entry that was applied
    pub entry: PatchEntry,
    /// Whether the patch was successfully applied
    pub success: bool,
    /// Description of what happened
    pub message: String,
}

/// The patch command implementation.
#[derive(Debug)]
pub struct PatchCommand {
    config: PatchConfig,
}

impl PatchCommand {
    /// Creates a new PatchCommand with the given configuration.
    pub fn new(config: PatchConfig) -> Self {
        Self { config }
    }

    /// Parses a patch file content into a list of patch entries.
    ///
    /// # Arguments
    /// * `content` - The patch file content as a string
    ///
    /// # Returns
    /// A vector of PatchEntry structs, or an error if parsing fails.
    ///
    /// # Format
    /// ```text
    /// # Comments start with #
    /// OFFSET:OLD_HEX:NEW_HEX
    /// ```
    ///
    /// # Examples
    /// ```
    /// use binfiddle::PatchCommand;
    /// use binfiddle::PatchConfig;
    ///
    /// let config = PatchConfig::default();
    /// let cmd = PatchCommand::new(config);
    /// let content = "# comment\n0x00:de:ff\n0x01:ad:00";
    /// let patches = cmd.parse_patch_file(content).unwrap();
    /// assert_eq!(patches.len(), 2);
    /// ```
    pub fn parse_patch_file(&self, content: &str) -> Result<Vec<PatchEntry>> {
        let mut entries = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line = line.trim();

            // Skip empty lines and comments
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // Parse the line: OFFSET:OLD_HEX:NEW_HEX
            let entry = self.parse_patch_line(line).map_err(|e| {
                BinfiddleError::Parse(format!("Line {}: {}", line_num + 1, e))
            })?;

            entries.push(entry);
        }

        Ok(entries)
    }

    /// Parses a single patch line.
    fn parse_patch_line(&self, line: &str) -> Result<PatchEntry> {
        // Split by colons
        let parts: Vec<&str> = line.splitn(3, ':').collect();

        if parts.len() != 3 {
            return Err(BinfiddleError::Parse(format!(
                "Invalid patch line format: '{}'. Expected OFFSET:OLD_HEX:NEW_HEX",
                line
            )));
        }

        // Parse offset (handle 0x prefix)
        let offset_str = parts[0].trim();
        let offset = self.parse_offset(offset_str)?;

        // Parse old bytes (may be empty)
        let old_bytes = self.parse_hex_bytes(parts[1].trim())?;

        // Parse new bytes (may be empty)
        let new_bytes = self.parse_hex_bytes(parts[2].trim())?;

        // Validate: at least one of old or new should be non-empty
        if old_bytes.is_empty() && new_bytes.is_empty() {
            return Err(BinfiddleError::Parse(format!(
                "Both old and new bytes are empty at offset 0x{:x}",
                offset
            )));
        }

        Ok(PatchEntry::new(offset, old_bytes, new_bytes))
    }

    /// Parses an offset string (handles 0x prefix).
    fn parse_offset(&self, s: &str) -> Result<usize> {
        let s = s.trim();
        let (s, radix) = if s.starts_with("0x") || s.starts_with("0X") {
            (&s[2..], 16)
        } else {
            // Default to hex for offsets
            (s, 16)
        };

        usize::from_str_radix(s, radix).map_err(|e| {
            BinfiddleError::Parse(format!("Invalid offset '{}': {}", s, e))
        })
    }

    /// Parses a hex string into bytes.
    fn parse_hex_bytes(&self, s: &str) -> Result<Vec<u8>> {
        let s = s.trim();
        if s.is_empty() {
            return Ok(Vec::new());
        }

        // Handle optional 0x prefix
        let s = if s.starts_with("0x") || s.starts_with("0X") {
            &s[2..]
        } else {
            s
        };

        // Remove spaces
        let s: String = s.chars().filter(|c| !c.is_whitespace()).collect();

        // Ensure even length
        if s.len() % 2 != 0 {
            return Err(BinfiddleError::Parse(format!(
                "Hex string '{}' has odd length",
                s
            )));
        }

        hex::decode(&s).map_err(|e| {
            BinfiddleError::Parse(format!("Invalid hex '{}': {}", s, e))
        })
    }

    /// Validates that a patch can be applied to the given data.
    ///
    /// Checks that:
    /// - All offsets are within bounds (considering old_bytes length)
    /// - Old bytes match the current data at each offset
    ///
    /// # Arguments
    /// * `data` - The data to validate against
    /// * `entries` - The patch entries to validate
    ///
    /// # Returns
    /// A vector of validation results for each entry.
    pub fn validate(&self, data: &[u8], entries: &[PatchEntry]) -> Vec<PatchResult> {
        let mut results = Vec::new();

        for entry in entries {
            let entry = if self.config.revert {
                entry.reversed()
            } else {
                entry.clone()
            };

            let result = self.validate_entry(data, &entry);
            results.push(result);
        }

        results
    }

    /// Validates a single patch entry.
    fn validate_entry(&self, data: &[u8], entry: &PatchEntry) -> PatchResult {
        // Check offset bounds
        if entry.offset >= data.len() && !entry.old_bytes.is_empty() {
            return PatchResult {
                entry: entry.clone(),
                success: false,
                message: format!(
                    "Offset 0x{:08x} is beyond file end (size: 0x{:x})",
                    entry.offset,
                    data.len()
                ),
            };
        }

        // For changes/deletions, verify old bytes match
        if !entry.old_bytes.is_empty() {
            let end_offset = entry.offset + entry.old_bytes.len();
            if end_offset > data.len() {
                return PatchResult {
                    entry: entry.clone(),
                    success: false,
                    message: format!(
                        "Old bytes at 0x{:08x} extend beyond file end (need {} bytes, only {} available)",
                        entry.offset,
                        entry.old_bytes.len(),
                        data.len() - entry.offset
                    ),
                };
            }

            let actual = &data[entry.offset..end_offset];
            if actual != entry.old_bytes.as_slice() {
                return PatchResult {
                    entry: entry.clone(),
                    success: false,
                    message: format!(
                        "Mismatch at 0x{:08x}: expected {}, found {}",
                        entry.offset,
                        hex::encode(&entry.old_bytes),
                        hex::encode(actual)
                    ),
                };
            }
        }

        // For additions, check if offset is valid (can be at end of file)
        if entry.is_addition() && entry.offset > data.len() {
            return PatchResult {
                entry: entry.clone(),
                success: false,
                message: format!(
                    "Addition offset 0x{:08x} is beyond file end (size: 0x{:x})",
                    entry.offset,
                    data.len()
                ),
            };
        }

        PatchResult {
            entry: entry.clone(),
            success: true,
            message: "OK".to_string(),
        }
    }

    /// Applies patches to the given data.
    ///
    /// # Arguments
    /// * `data` - The data to modify
    /// * `entries` - The patch entries to apply
    ///
    /// # Returns
    /// A tuple of (modified_data, results) where results indicate what happened.
    ///
    /// # Notes
    /// - Patches are applied in order
    /// - For changes: old bytes are replaced with new bytes (must be same length)
    /// - For pure additions: bytes are inserted at offset
    /// - For pure deletions: bytes are removed from offset
    ///
    /// Currently, only same-length changes are supported for simplicity.
    /// Different-length changes are reported as errors.
    pub fn apply(&self, data: &[u8], entries: &[PatchEntry]) -> Result<(Vec<u8>, Vec<PatchResult>)> {
        let mut result_data = data.to_vec();
        let mut results = Vec::new();

        // First, validate all entries
        let validation = self.validate(&result_data, entries);
        let all_valid = validation.iter().all(|r| r.success);

        if !all_valid && !self.config.dry_run {
            // Return validation results without modifying data
            return Ok((data.to_vec(), validation));
        }

        if self.config.dry_run {
            return Ok((data.to_vec(), validation));
        }

        // Apply patches
        for entry in entries {
            let entry = if self.config.revert {
                entry.reversed()
            } else {
                entry.clone()
            };

            let result = self.apply_entry(&mut result_data, &entry);
            results.push(result);
        }

        Ok((result_data, results))
    }

    /// Applies a single patch entry.
    fn apply_entry(&self, data: &mut Vec<u8>, entry: &PatchEntry) -> PatchResult {
        // Handle different patch types
        if entry.is_change() {
            // Same-length change
            if entry.old_bytes.len() != entry.new_bytes.len() {
                return PatchResult {
                    entry: entry.clone(),
                    success: false,
                    message: format!(
                        "Different-length change at 0x{:08x}: old={} bytes, new={} bytes (not supported)",
                        entry.offset,
                        entry.old_bytes.len(),
                        entry.new_bytes.len()
                    ),
                };
            }

            // Replace bytes
            let end = entry.offset + entry.new_bytes.len();
            data[entry.offset..end].copy_from_slice(&entry.new_bytes);

            PatchResult {
                entry: entry.clone(),
                success: true,
                message: format!(
                    "Changed {} byte(s) at 0x{:08x}",
                    entry.new_bytes.len(),
                    entry.offset
                ),
            }
        } else if entry.is_addition() {
            // Insert bytes
            // Note: This changes file length, which may affect subsequent offsets
            // For now, we only support additions at the end of file
            if entry.offset != data.len() {
                return PatchResult {
                    entry: entry.clone(),
                    success: false,
                    message: format!(
                        "Insertion at 0x{:08x} not at end of file (not yet supported)",
                        entry.offset
                    ),
                };
            }

            data.extend_from_slice(&entry.new_bytes);

            PatchResult {
                entry: entry.clone(),
                success: true,
                message: format!(
                    "Added {} byte(s) at 0x{:08x}",
                    entry.new_bytes.len(),
                    entry.offset
                ),
            }
        } else if entry.is_deletion() {
            // Remove bytes
            // Note: This changes file length, which may affect subsequent offsets
            // For now, we only support deletions at the end of file
            let end = entry.offset + entry.old_bytes.len();
            if end != data.len() {
                return PatchResult {
                    entry: entry.clone(),
                    success: false,
                    message: format!(
                        "Deletion at 0x{:08x} not at end of file (not yet supported)",
                        entry.offset
                    ),
                };
            }

            data.truncate(entry.offset);

            PatchResult {
                entry: entry.clone(),
                success: true,
                message: format!(
                    "Removed {} byte(s) at 0x{:08x}",
                    entry.old_bytes.len(),
                    entry.offset
                ),
            }
        } else {
            PatchResult {
                entry: entry.clone(),
                success: false,
                message: "Empty patch entry (both old and new are empty)".to_string(),
            }
        }
    }

    /// Formats the results of a patch operation for display.
    ///
    /// # Arguments
    /// * `results` - The patch results to format
    /// * `dry_run` - Whether this was a dry run
    ///
    /// # Returns
    /// A formatted string suitable for terminal output.
    pub fn format_results(&self, results: &[PatchResult]) -> String {
        let mut output = String::new();

        if self.config.dry_run {
            output.push_str("Dry run - no changes made:\n\n");
        }

        let mut success_count = 0;
        let mut failure_count = 0;

        for result in results {
            let status = if result.success {
                success_count += 1;
                "✓"
            } else {
                failure_count += 1;
                "✗"
            };

            let entry = &result.entry;
            let old_hex = if entry.old_bytes.is_empty() {
                "(empty)".to_string()
            } else {
                hex::encode(&entry.old_bytes)
            };
            let new_hex = if entry.new_bytes.is_empty() {
                "(empty)".to_string()
            } else {
                hex::encode(&entry.new_bytes)
            };

            output.push_str(&format!(
                "{} 0x{:08x}: {} -> {}\n   {}\n",
                status, entry.offset, old_hex, new_hex, result.message
            ));
        }

        output.push_str(&format!(
            "\nSummary: {} succeeded, {} failed\n",
            success_count, failure_count
        ));

        output
    }

    /// Creates a backup of the target file.
    ///
    /// # Arguments
    /// * `target_path` - Path to the file to backup
    /// * `suffix` - Suffix to append (e.g., ".bak")
    ///
    /// # Returns
    /// The path to the backup file.
    pub fn create_backup(target_path: &str, suffix: &str) -> Result<String> {
        let backup_path = format!("{}{}", target_path, suffix);
        std::fs::copy(target_path, &backup_path)?;
        Ok(backup_path)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_patch_line_simple() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let entry = cmd.parse_patch_line("0x00000000:de:ff").unwrap();
        assert_eq!(entry.offset, 0);
        assert_eq!(entry.old_bytes, vec![0xde]);
        assert_eq!(entry.new_bytes, vec![0xff]);
    }

    #[test]
    fn test_parse_patch_line_multi_byte() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let entry = cmd.parse_patch_line("0x100:deadbeef:cafebabe").unwrap();
        assert_eq!(entry.offset, 0x100);
        assert_eq!(entry.old_bytes, vec![0xde, 0xad, 0xbe, 0xef]);
        assert_eq!(entry.new_bytes, vec![0xca, 0xfe, 0xba, 0xbe]);
    }

    #[test]
    fn test_parse_patch_line_addition() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let entry = cmd.parse_patch_line("0x00::ff").unwrap();
        assert_eq!(entry.offset, 0);
        assert!(entry.old_bytes.is_empty());
        assert_eq!(entry.new_bytes, vec![0xff]);
        assert!(entry.is_addition());
    }

    #[test]
    fn test_parse_patch_line_deletion() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let entry = cmd.parse_patch_line("0x00:de:").unwrap();
        assert_eq!(entry.offset, 0);
        assert_eq!(entry.old_bytes, vec![0xde]);
        assert!(entry.new_bytes.is_empty());
        assert!(entry.is_deletion());
    }

    #[test]
    fn test_parse_patch_file() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let content = r#"# binfiddle patch file
# source: original.bin
# target: modified.bin
# format: OFFSET:OLD_HEX:NEW_HEX
# differences: 2
#
0x00000000:de:ff
0x00000002:22:33
"#;

        let entries = cmd.parse_patch_file(content).unwrap();
        assert_eq!(entries.len(), 2);
        assert_eq!(entries[0].offset, 0);
        assert_eq!(entries[0].old_bytes, vec![0xde]);
        assert_eq!(entries[0].new_bytes, vec![0xff]);
        assert_eq!(entries[1].offset, 2);
    }

    #[test]
    fn test_parse_patch_file_empty_lines() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let content = "0x00:aa:bb\n\n0x01:cc:dd\n";
        let entries = cmd.parse_patch_file(content).unwrap();
        assert_eq!(entries.len(), 2);
    }

    #[test]
    fn test_parse_offset_no_prefix() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        assert_eq!(cmd.parse_offset("100").unwrap(), 0x100);
        assert_eq!(cmd.parse_offset("ff").unwrap(), 0xff);
    }

    #[test]
    fn test_validate_success() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad, 0xbe, 0xef];
        let entries = vec![PatchEntry::new(0, vec![0xde], vec![0xff])];

        let results = cmd.validate(&data, &entries);
        assert_eq!(results.len(), 1);
        assert!(results[0].success);
    }

    #[test]
    fn test_validate_mismatch() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad, 0xbe, 0xef];
        let entries = vec![PatchEntry::new(0, vec![0xff], vec![0x00])]; // Wrong expected byte

        let results = cmd.validate(&data, &entries);
        assert_eq!(results.len(), 1);
        assert!(!results[0].success);
        assert!(results[0].message.contains("Mismatch"));
    }

    #[test]
    fn test_validate_out_of_bounds() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad];
        let entries = vec![PatchEntry::new(100, vec![0xff], vec![0x00])];

        let results = cmd.validate(&data, &entries);
        assert!(!results[0].success);
        assert!(results[0].message.contains("beyond"));
    }

    #[test]
    fn test_apply_simple_change() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad, 0xbe, 0xef];
        let entries = vec![PatchEntry::new(0, vec![0xde], vec![0xff])];

        let (result, _) = cmd.apply(&data, &entries).unwrap();
        assert_eq!(result, vec![0xff, 0xad, 0xbe, 0xef]);
    }

    #[test]
    fn test_apply_multiple_changes() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad, 0xbe, 0xef];
        let entries = vec![
            PatchEntry::new(0, vec![0xde], vec![0x00]),
            PatchEntry::new(3, vec![0xef], vec![0xff]),
        ];

        let (result, _) = cmd.apply(&data, &entries).unwrap();
        assert_eq!(result, vec![0x00, 0xad, 0xbe, 0xff]);
    }

    #[test]
    fn test_apply_dry_run() {
        let config = PatchConfig {
            dry_run: true,
            ..Default::default()
        };
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad, 0xbe, 0xef];
        let entries = vec![PatchEntry::new(0, vec![0xde], vec![0xff])];

        let (result, _) = cmd.apply(&data, &entries).unwrap();
        // Data should be unchanged in dry run
        assert_eq!(result, data);
    }

    #[test]
    fn test_apply_revert() {
        let config = PatchConfig {
            revert: true,
            ..Default::default()
        };
        let cmd = PatchCommand::new(config);

        // If we applied 0xde -> 0xff, reverting should do 0xff -> 0xde
        let data = vec![0xff, 0xad, 0xbe, 0xef];
        let entries = vec![PatchEntry::new(0, vec![0xde], vec![0xff])];

        let (result, _) = cmd.apply(&data, &entries).unwrap();
        assert_eq!(result, vec![0xde, 0xad, 0xbe, 0xef]);
    }

    #[test]
    fn test_patch_entry_types() {
        let change = PatchEntry::new(0, vec![0xaa], vec![0xbb]);
        assert!(change.is_change());
        assert!(!change.is_addition());
        assert!(!change.is_deletion());

        let addition = PatchEntry::new(0, vec![], vec![0xcc]);
        assert!(!addition.is_change());
        assert!(addition.is_addition());
        assert!(!addition.is_deletion());

        let deletion = PatchEntry::new(0, vec![0xdd], vec![]);
        assert!(!deletion.is_change());
        assert!(!deletion.is_addition());
        assert!(deletion.is_deletion());
    }

    #[test]
    fn test_patch_entry_reversed() {
        let entry = PatchEntry::new(10, vec![0xaa, 0xbb], vec![0xcc, 0xdd]);
        let reversed = entry.reversed();

        assert_eq!(reversed.offset, 10);
        assert_eq!(reversed.old_bytes, vec![0xcc, 0xdd]);
        assert_eq!(reversed.new_bytes, vec![0xaa, 0xbb]);
    }

    #[test]
    fn test_format_results() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let results = vec![
            PatchResult {
                entry: PatchEntry::new(0, vec![0xde], vec![0xff]),
                success: true,
                message: "Changed 1 byte(s) at 0x00000000".to_string(),
            },
            PatchResult {
                entry: PatchEntry::new(10, vec![0xaa], vec![0xbb]),
                success: false,
                message: "Mismatch at 0x0000000a".to_string(),
            },
        ];

        let output = cmd.format_results(&results);
        assert!(output.contains("✓"));
        assert!(output.contains("✗"));
        assert!(output.contains("1 succeeded"));
        assert!(output.contains("1 failed"));
    }

    #[test]
    fn test_parse_hex_bytes_empty() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let bytes = cmd.parse_hex_bytes("").unwrap();
        assert!(bytes.is_empty());
    }

    #[test]
    fn test_parse_hex_bytes_with_prefix() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let bytes = cmd.parse_hex_bytes("0xdeadbeef").unwrap();
        assert_eq!(bytes, vec![0xde, 0xad, 0xbe, 0xef]);
    }

    #[test]
    fn test_parse_invalid_patch_line() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        // Missing colon
        assert!(cmd.parse_patch_line("0x00de").is_err());

        // Invalid hex
        assert!(cmd.parse_patch_line("0x00:gg:ff").is_err());

        // Both empty
        assert!(cmd.parse_patch_line("0x00::").is_err());
    }

    #[test]
    fn test_validate_addition_at_end() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad];
        let entries = vec![PatchEntry::new(2, vec![], vec![0xff])];

        let results = cmd.validate(&data, &entries);
        assert!(results[0].success);
    }

    #[test]
    fn test_apply_addition_at_end() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad];
        let entries = vec![PatchEntry::new(2, vec![], vec![0xbe, 0xef])];

        let (result, _) = cmd.apply(&data, &entries).unwrap();
        assert_eq!(result, vec![0xde, 0xad, 0xbe, 0xef]);
    }

    #[test]
    fn test_apply_deletion_at_end() {
        let config = PatchConfig::default();
        let cmd = PatchCommand::new(config);

        let data = vec![0xde, 0xad, 0xbe, 0xef];
        let entries = vec![PatchEntry::new(2, vec![0xbe, 0xef], vec![])];

        let (result, _) = cmd.apply(&data, &entries).unwrap();
        assert_eq!(result, vec![0xde, 0xad]);
    }
}
